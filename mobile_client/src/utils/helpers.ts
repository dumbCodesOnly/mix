/**\n * Utility helper functions for the mobile client.\n */\n\n/**\n * Format bytes to human-readable size.\n */\nexport function formatBytes(bytes: number, decimals: number = 2): string {\n  if (bytes === 0) return '0 Bytes';\n\n  const k = 1024;\n  const dm = decimals < 0 ? 0 : decimals;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];\n}\n\n/**\n * Format duration in seconds to human-readable format.\n */\nexport function formatDuration(seconds: number): string {\n  if (seconds < 60) {\n    return `${Math.round(seconds)}s`;\n  }\n\n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = Math.round(seconds % 60);\n\n  if (minutes < 60) {\n    return `${minutes}m ${remainingSeconds}s`;\n  }\n\n  const hours = Math.floor(minutes / 60);\n  const remainingMinutes = minutes % 60;\n\n  return `${hours}h ${remainingMinutes}m`;\n}\n\n/**\n * Truncate text to a maximum length.\n */\nexport function truncateText(text: string, maxLength: number): string {\n  if (text.length <= maxLength) {\n    return text;\n  }\n  return text.substring(0, maxLength - 3) + '...';\n}\n\n/**\n * Validate if a URL is valid.\n */\nexport function isValidURL(url: string): boolean {\n  try {\n    new URL(url);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Convert base64 string to Blob.\n */\nexport function base64ToBlob(base64: string, mimeType: string = 'image/png'): Blob {\n  const byteCharacters = atob(base64);\n  const byteNumbers = new Array(byteCharacters.length);\n  for (let i = 0; i < byteCharacters.length; i++) {\n    byteNumbers[i] = byteCharacters.charCodeAt(i);\n  }\n  const byteArray = new Uint8Array(byteNumbers);\n  return new Blob([byteArray], { type: mimeType });\n}\n\n/**\n * Convert Blob to base64 string.\n */\nexport function blobToBase64(blob: Blob): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = () => {\n      const base64 = reader.result as string;\n      resolve(base64.split(',')[1] || '');\n    };\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n}\n\n/**\n * Debounce a function.\n */\nexport function debounce<T extends (...args: unknown[]) => unknown>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout | null = null;\n\n  return function executedFunction(...args: Parameters<T>) {\n    const later = () => {\n      timeout = null;\n      func(...args);\n    };\n\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(later, wait);\n  };\n}\n\n/**\n * Throttle a function.\n */\nexport function throttle<T extends (...args: unknown[]) => unknown>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let inThrottle: boolean = false;\n\n  return function (...args: Parameters<T>) {\n    if (!inThrottle) {\n      func(...args);\n      inThrottle = true;\n      setTimeout(() => {\n        inThrottle = false;\n      }, limit);\n    }\n  };\n}\n\n/**\n * Generate a unique ID.\n */\nexport function generateId(): string {\n  return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\n/**\n * Check if device is online.\n */\nexport async function isOnline(): Promise<boolean> {\n  try {\n    const response = await fetch('https://www.google.com', {\n      method: 'HEAD',\n      mode: 'no-cors',\n    });\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Retry a function with exponential backoff.\n */\nexport async function retryWithBackoff<T>(\n  func: () => Promise<T>,\n  maxRetries: number = 3,\n  initialDelay: number = 1000\n): Promise<T> {\n  let lastError: Error | null = null;\n  let delay = initialDelay;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await func();\n    } catch (error) {\n      lastError = error as Error;\n      if (attempt < maxRetries) {\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        delay *= 2;\n      }\n    }\n  }\n\n  throw lastError || new Error('Failed after retries');\n}\n
