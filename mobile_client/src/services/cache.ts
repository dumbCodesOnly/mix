/**\n * Image and data caching service.\n *\n * This module provides a multi-level caching strategy with memory cache,\n * disk cache, and automatic cache invalidation.\n */\n\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport * as FileSystem from 'expo-file-system';\n\ninterface CacheEntry<T> {\n  data: T;\n  timestamp: number;\n  expiresAt?: number;\n}\n\ninterface CacheConfig {\n  maxMemoryItems: number;\n  maxDiskSizeMB: number;\n  defaultTTLSeconds: number;\n}\n\nclass CacheService {\n  private memoryCache: Map<string, CacheEntry<unknown>> = new Map();\n  private config: CacheConfig;\n  private diskCacheDir: string;\n\n  constructor(\n    maxMemoryItems: number = 50,\n    maxDiskSizeMB: number = 100,\n    defaultTTLSeconds: number = 3600 // 1 hour\n  ) {\n    this.config = {\n      maxMemoryItems,\n      maxDiskSizeMB,\n      defaultTTLSeconds,\n    };\n    this.diskCacheDir = `${FileSystem.cacheDirectory}ai-platform-cache/`;\n    this.initializeCacheDir();\n  }\n\n  /**\n   * Initialize the cache directory.\n   */\n  private async initializeCacheDir(): Promise<void> {\n    try {\n      const dirInfo = await FileSystem.getInfoAsync(this.diskCacheDir);\n      if (!dirInfo.exists) {\n        await FileSystem.makeDirectoryAsync(this.diskCacheDir, {\n          intermediates: true,\n        });\n      }\n    } catch (error) {\n      console.error('Failed to initialize cache directory:', error);\n    }\n  }\n\n  /**\n   * Generate a cache key from a string.\n   */\n  private generateKey(input: string): string {\n    // Simple hash function for cache keys\n    let hash = 0;\n    for (let i = 0; i < input.length; i++) {\n      const char = input.charCodeAt(i);\n      hash = (hash << 5) - hash + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return `cache_${Math.abs(hash)}`;\n  }\n\n  /**\n   * Get data from cache (memory first, then disk).\n   */\n  async get<T>(key: string): Promise<T | null> {\n    // Check memory cache first\n    const memoryEntry = this.memoryCache.get(key);\n    if (memoryEntry && this.isValid(memoryEntry)) {\n      return memoryEntry.data as T;\n    }\n\n    // Check disk cache\n    try {\n      const diskData = await AsyncStorage.getItem(key);\n      if (diskData) {\n        const entry: CacheEntry<T> = JSON.parse(diskData);\n        if (this.isValid(entry)) {\n          // Restore to memory cache\n          this.memoryCache.set(key, entry);\n          return entry.data;\n        } else {\n          // Remove expired entry\n          await this.remove(key);\n        }\n      }\n    } catch (error) {\n      console.error(`Failed to retrieve cache for key ${key}:`, error);\n    }\n\n    return null;\n  }\n\n  /**\n   * Set data in cache (both memory and disk).\n   */\n  async set<T>(\n    key: string,\n    data: T,\n    ttlSeconds?: number\n  ): Promise<void> {\n    const ttl = ttlSeconds || this.config.defaultTTLSeconds;\n    const entry: CacheEntry<T> = {\n      data,\n      timestamp: Date.now(),\n      expiresAt: Date.now() + ttl * 1000,\n    };\n\n    // Add to memory cache\n    this.memoryCache.set(key, entry);\n\n    // Enforce memory cache size limit\n    if (this.memoryCache.size > this.config.maxMemoryItems) {\n      const firstKey = this.memoryCache.keys().next().value;\n      if (firstKey) {\n        this.memoryCache.delete(firstKey);\n      }\n    }\n\n    // Add to disk cache\n    try {\n      await AsyncStorage.setItem(key, JSON.stringify(entry));\n    } catch (error) {\n      console.error(`Failed to cache data for key ${key}:`, error);\n    }\n  }\n\n  /**\n   * Cache an image blob.\n   */\n  async cacheImage(prompt: string, imageBlob: Blob): Promise<string> {\n    const key = this.generateKey(prompt);\n    const filePath = `${this.diskCacheDir}${key}.png`;\n\n    try {\n      // Convert blob to base64\n      const base64 = await this.blobToBase64(imageBlob);\n\n      // Save to disk\n      await FileSystem.writeAsStringAsync(filePath, base64, {\n        encoding: FileSystem.EncodingType.Base64,\n      });\n\n      // Store metadata in AsyncStorage\n      const metadata = {\n        path: filePath,\n        timestamp: Date.now(),\n        size: imageBlob.size,\n      };\n      await AsyncStorage.setItem(`${key}_meta`, JSON.stringify(metadata));\n\n      return filePath;\n    } catch (error) {\n      console.error(`Failed to cache image for prompt \"${prompt}\":`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get cached image by prompt.\n   */\n  async getCachedImage(prompt: string): Promise<string | null> {\n    const key = this.generateKey(prompt);\n    const filePath = `${this.diskCacheDir}${key}.png`;\n\n    try {\n      const fileInfo = await FileSystem.getInfoAsync(filePath);\n      if (fileInfo.exists) {\n        return filePath;\n      }\n    } catch (error) {\n      console.error(`Failed to retrieve cached image for prompt \"${prompt}\":`, error);\n    }\n\n    return null;\n  }\n\n  /**\n   * Remove a cache entry.\n   */\n  async remove(key: string): Promise<void> {\n    // Remove from memory cache\n    this.memoryCache.delete(key);\n\n    // Remove from disk cache\n    try {\n      await AsyncStorage.removeItem(key);\n      await AsyncStorage.removeItem(`${key}_meta`);\n    } catch (error) {\n      console.error(`Failed to remove cache for key ${key}:`, error);\n    }\n  }\n\n  /**\n   * Clear all cache.\n   */\n  async clear(): Promise<void> {\n    // Clear memory cache\n    this.memoryCache.clear();\n\n    // Clear disk cache\n    try {\n      const keys = await AsyncStorage.getAllKeys();\n      const cacheKeys = keys.filter((key) => key.startsWith('cache_'));\n      await AsyncStorage.multiRemove(cacheKeys);\n\n      // Clear cache directory\n      const files = await FileSystem.readDirectoryAsync(this.diskCacheDir);\n      for (const file of files) {\n        await FileSystem.deleteAsync(`${this.diskCacheDir}${file}`);\n      }\n    } catch (error) {\n      console.error('Failed to clear cache:', error);\n    }\n  }\n\n  /**\n   * Get cache statistics.\n   */\n  async getStats(): Promise<{\n    memoryItems: number;\n    diskSize: number;\n  }> {\n    let diskSize = 0;\n\n    try {\n      const files = await FileSystem.readDirectoryAsync(this.diskCacheDir);\n      for (const file of files) {\n        const fileInfo = await FileSystem.getInfoAsync(\n          `${this.diskCacheDir}${file}`\n        );\n        if (fileInfo.size) {\n          diskSize += fileInfo.size;\n        }\n      }\n    } catch (error) {\n      console.error('Failed to get cache stats:', error);\n    }\n\n    return {\n      memoryItems: this.memoryCache.size,\n      diskSize,\n    };\n  }\n\n  /**\n   * Check if a cache entry is still valid.\n   */\n  private isValid(entry: CacheEntry<unknown>): boolean {\n    if (!entry.expiresAt) {\n      return true;\n    }\n    return Date.now() < entry.expiresAt;\n  }\n\n  /**\n   * Convert a Blob to base64 string.\n   */\n  private blobToBase64(blob: Blob): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        const base64 = reader.result as string;\n        resolve(base64.split(',')[1] || '');\n      };\n      reader.onerror = reject;\n      reader.readAsDataURL(blob);\n    });\n  }\n}\n\n// Global cache service instance\nlet cacheService: CacheService | null = null;\n\n/**\n * Get or create the global cache service instance.\n */\nexport function getCacheService(): CacheService {\n  if (!cacheService) {\n    cacheService = new CacheService();\n  }\n  return cacheService;\n}\n\nexport default getCacheService;\nexport type { CacheEntry, CacheConfig };\n
